#! /usr/bin/env python3

import logging
import os
import os.path
import tempfile

from git import Repo
from sphinx.ext.intersphinx import fetch_inventory

logging.getLogger().setLevel(logging.INFO)


SPHINX_OBJECTS_URL = "https://docs.python.org/{}/objects.inv"
CPYTHON_GIT_URL = "https://github.com/python/cpython.git"
VERSIONS = [
    "3.3",
    "3.4",
    "3.5",
    "3.6",
    "3.7",
    "3.8",
    "3.9",
    "3.10",
    "3.11",
]
TARGET_GO_MODULE = "internal/frame/python_std_lib.go"


class FakeConfig:
    intersphinx_timeout = None
    tls_verify = True
    user_agent = ""


class FakeApp:
    srcdir = ""
    config = FakeConfig()


SKIPPED_MODULES = {"__main__"}


def fetch_documented_modules(versions):
    """
    Fetches the list of publically documented modules found on https//docs.python.org.
    This list is incomplete as the private internal modules used by Cpython will not be found here.

    Adapted from https://github.com/PyCQA/isort/blob/e321a670d0fefdea0e04ed9d8d696434cf49bdec/scripts/mkstdlibs.py
    """

    logging.info("Fetching documented modules")

    for version in versions:
        logging.info("Fetching documented modules for %s", version)

        url = SPHINX_OBJECTS_URL.format(version)
        invdata = fetch_inventory(FakeApp(), "", url)

        for module in invdata["py:module"]:
            root = module.split(".", 1)[0]
            if root not in SKIPPED_MODULES:
                yield root


def fetch_git_modules(versions):
    """
    Fetches a list of python modules (not native modules) by traversing CPython source.
    This list captures the internal modules used by CPython that is undocumented.

    This does NOT find the native modules at the moment. Native modules also do not
    appear in python profiles at the moment so this is a non issue for now.
    """

    logging.info("Fetching git modules")

    with tempfile.TemporaryDirectory() as dir_name:
        logging.info("Cloning CPython")

        repo = Repo.clone_from(CPYTHON_GIT_URL, dir_name)

        # most of the python libraries are defined in this folder
        lib_dir = os.path.join(dir_name, "Lib")

        for version in versions:
            logging.info("Fetching git modules for %s", version)

            repo.git.checkout(version)

            for name in os.listdir(lib_dir):
                path = os.path.join(lib_dir, name)

                if os.path.isdir(path):
                    # if it's a directory, it should contain an `__init__.py`
                    # if it's also a module
                    init_path = os.path.join(path, "__init__.py")
                    if not os.path.exists(init_path):
                        continue
                    module = os.path.basename(path)

                elif os.path.isfile(path):
                    # if it's a file, it should end with `.py`
                    # if it's also a module
                    module, ext = os.path.splitext(path)
                    if ext != ".py":
                        continue
                    module = os.path.basename(module)

                yield module


PYTHON_STD_LIB_GO_TEMPLATE = \
    """// This file is autogenerated from scripts/make_python_stdlib.py
// To update this file, update the python versions list in
// scripts/make_python_stdlib.py then run `make python-stdlib`
package frame

var (
\tpythonStdlib = map[string]bool{{
{modules}
\t}}
)
"""


def generate_python_std_lib_go(modules):
    logging.info("Generating Python stdlib module")
    max_len = max(len(module) for module in modules)
    module_keys = [
        f'"{module}":'.ljust(max_len + 3, " ")
        for module in sorted(modules)
    ]
    formatted_modules = "\n".join(
        f'\t\t{module} true,' for module in module_keys
    )
    return PYTHON_STD_LIB_GO_TEMPLATE.format(modules=formatted_modules)


def main():

    # Any modules we want to enforce across Python versions stdlib can be
    # included in set init
    modules = {
        "_ast",
        "posixpath",
        "ntpath",
        "sre_constants",
        "sre_parse",
        "sre_compile",
        "sre",
    }

    for module in fetch_documented_modules(VERSIONS):
        modules.add(module)

    for module in fetch_git_modules(VERSIONS):
        modules.add(module)

    with open(TARGET_GO_MODULE, "w") as f:
        f.write(generate_python_std_lib_go(modules))


if __name__ == "__main__":
    main()
